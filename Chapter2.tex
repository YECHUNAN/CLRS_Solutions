\documentclass[]{article}

%opening
\title{}
\author{}

\begin{document}
\title{Chapter 2 solution}
\maketitle

\begin{enumerate}
\item[2.1-1]

A = \{31, 41, 59, 26, 41, 58\} use insertion sort in ascending order

\noindent
After step 1:\\
	A = \{31, 41, 59, 26, 41, 58\}
	
After step 2:\\
	A = \{31, 41, 59, 26, 41, 58\}
	
After step 3:\\
	A = \{31, 41, 59, 26, 41, 58\}
	
After step 4:\\
	A = \{26, 31, 41, 59, 41, 58\}
	
After step 5:\\
	A = \{26, 31, 41, 41, 59, 58\}
	
After step 6:\\
	A = \{26, 31, 41, 41, 58, 59\}

\item[2.1-2] Rewrite insertion sort in descending order\\
Insertion-Sort(A)\\
1 for	j = 2 to A.length\\
2 \ \ \ \ key = A[j]\\
3 \ \ \ \ while i$>$0 and A[i]$<$key\\
4 \ \ \ \ \ \ \ \ A[i+1] = A[i]\\
5 \ \ \ \ \ \ \ \ i = i-1\\
6 \ \ \ \ A[i+1] = key\\

\item[2.1-3] Write pseudo-code for linear search problem\\
Linear-Search-Problem(A, v)\\
1 rt = NIL\\
2 for i = 1 to A.length\\
3 \ \ \ \ if A[i] == v\\
4 \ \ \ \ \ \ \ \ rt = i\\
5 \ \ \ \ \ \ \ \ break\\

\noindent
Proof:\\
Loop invariant: at iteration when i = k, v doesn't exist in A[1:k-1]\\
Initialization: i = 1, trivial case as there is nothing in A[1:0]\\
Maintenance: if v is in A[1:k-1] at A[j], then the loop will break when i=j\\
Termination: This is also obvious.

\item[2.1-4] Adding two n-bit binary integers A and B to (n+1) elements array C\\

Add-Binary-Integer(A, B)\\
1 int i=A.length\\
2 int j=B.length\\
3 allocate C as C[1:k] where k = max(i,j)+1\\
4 int m=max(i,j)+1\\
5 int carry = 0\\
6 while i$>$0 and j$ > $0\\
7 \ \ \ \ C[m] = A[i] xor B[j] xor carry\\
8 \ \ \ \ carry = (A[i] \& B[j]) $|$ (A[i] \& carry) $|$ (carry \& B[j])\\
9  m = m-1\\
10 i = i-1\\
11 j = j-1\\
12 while i$>$0 \\
13 \ \ \ \ C[m] = A[i] xor carry\\
14 \ \ \ \ carry = A[i] \& carry\\
15 \ \ \ \ i = i-1\\
16 \ \ \ \ m = m-1\\
17 while j$>$0 \\
18 \ \ \ \ C[m] = A[i] xor carry\\
19 \ \ \ \ carry = A[i] \& carry\\
20 \ \ \ \ j = j-1
21 \ \ \ \ m = m-1\\

\item[2.2-1] $$ n^3/1000 - 100n^2 -100n +3 = \Theta(n^3) $$

\item[2.2-2] Selection sort Loop invariant:\\
 before the i th iteration, the sub-array A[1:i-1] is sorted.\\
Within the i th iteration, the smallest element of the sub-array A[i:A.length] will be placed at A[i]\\

\noindent
Because after placing the first n-1 elements, the n th element is mutually at the right position.

\noindent
The best-case time complexity is $$ \Theta(n^2) $$
The worst-case time complexity is $$ \Theta(n^2) $$
There is no big difference in the best case and the worst case because it always takes (n-1)n/2 iterations, the difference is only about a constant number of operations within each iteration depending on whether we swap elements or not.

\item[2.2-3] The average number of elements needed to be checked is $$ \sum_{i=1}^{n}\frac{1}{n} * i = \frac{1+n}{2} $$
Worst case is n elements\\
Worst case time complexity: $$ \Theta(n) $$
Average case time complexity: $$ \Theta(n) $$

How to modify almost any algorithm to have a good best-case running time?\\
I am not sure, maybe storing the result for some special/frequent cases to achieve O(1) complexity in best case.

\end{enumerate}


\end{document}
